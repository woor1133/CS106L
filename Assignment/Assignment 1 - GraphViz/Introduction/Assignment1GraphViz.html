<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=dpiI8CyVsrzWsJLBFKehGpLhv3qFjX7dUn1mYxfCXhI);.lst-kix_drqcbiukht3e-8>li:before{content:"\0025a0   "}.lst-kix_drqcbiukht3e-7>li:before{content:"\0025cb   "}.lst-kix_drqcbiukht3e-4>li:before{content:"\0025cb   "}.lst-kix_drqcbiukht3e-3>li:before{content:"\0025cf   "}.lst-kix_drqcbiukht3e-2>li:before{content:"\0025a0   "}.lst-kix_drqcbiukht3e-5>li:before{content:"\0025a0   "}.lst-kix_drqcbiukht3e-6>li:before{content:"\0025cf   "}.lst-kix_4t4rzoylkxr4-6>li:before{content:"\0025cf   "}.lst-kix_4t4rzoylkxr4-5>li:before{content:"\0025a0   "}.lst-kix_4t4rzoylkxr4-7>li:before{content:"\0025cb   "}ul.lst-kix_prld07vdvfck-1{list-style-type:none}ul.lst-kix_prld07vdvfck-0{list-style-type:none}ul.lst-kix_prld07vdvfck-5{list-style-type:none}ul.lst-kix_prld07vdvfck-4{list-style-type:none}ul.lst-kix_prld07vdvfck-3{list-style-type:none}.lst-kix_4t4rzoylkxr4-3>li:before{content:"\0025cf   "}ul.lst-kix_prld07vdvfck-2{list-style-type:none}.lst-kix_4t4rzoylkxr4-4>li:before{content:"\0025cb   "}ul.lst-kix_prld07vdvfck-8{list-style-type:none}ul.lst-kix_prld07vdvfck-7{list-style-type:none}ul.lst-kix_prld07vdvfck-6{list-style-type:none}.lst-kix_4t4rzoylkxr4-8>li:before{content:"\0025a0   "}ul.lst-kix_av8977phuwuc-3{list-style-type:none}ul.lst-kix_av8977phuwuc-4{list-style-type:none}.lst-kix_prld07vdvfck-0>li:before{content:"\0025cf   "}ul.lst-kix_av8977phuwuc-5{list-style-type:none}ul.lst-kix_av8977phuwuc-6{list-style-type:none}ul.lst-kix_av8977phuwuc-7{list-style-type:none}ul.lst-kix_av8977phuwuc-8{list-style-type:none}.lst-kix_4t4rzoylkxr4-2>li:before{content:"\0025a0   "}.lst-kix_4t4rzoylkxr4-1>li:before{content:"\0025cb   "}.lst-kix_4t4rzoylkxr4-0>li:before{content:"\0025cf   "}.lst-kix_tp0sy78gqk8h-2>li:before{content:"\0025a0   "}.lst-kix_tp0sy78gqk8h-1>li:before{content:"\0025cb   "}.lst-kix_tp0sy78gqk8h-3>li:before{content:"\0025cf   "}.lst-kix_tp0sy78gqk8h-0>li:before{content:"\0025cf   "}.lst-kix_tp0sy78gqk8h-4>li:before{content:"\0025cb   "}.lst-kix_zcnwg2w0gc0a-8>li:before{content:"\0025a0   "}.lst-kix_tp0sy78gqk8h-8>li:before{content:"\0025a0   "}ul.lst-kix_av8977phuwuc-0{list-style-type:none}ul.lst-kix_av8977phuwuc-1{list-style-type:none}ul.lst-kix_av8977phuwuc-2{list-style-type:none}.lst-kix_zcnwg2w0gc0a-5>li:before{content:"\0025a0   "}.lst-kix_tp0sy78gqk8h-6>li:before{content:"\0025cf   "}.lst-kix_zcnwg2w0gc0a-6>li:before{content:"\0025cf   "}.lst-kix_tp0sy78gqk8h-5>li:before{content:"\0025a0   "}.lst-kix_tp0sy78gqk8h-7>li:before{content:"\0025cb   "}.lst-kix_zcnwg2w0gc0a-7>li:before{content:"\0025cb   "}.lst-kix_zcnwg2w0gc0a-0>li:before{content:"\0025cf   "}.lst-kix_zcnwg2w0gc0a-2>li:before{content:"\0025a0   "}ul.lst-kix_tp0sy78gqk8h-7{list-style-type:none}ul.lst-kix_tp0sy78gqk8h-8{list-style-type:none}ul.lst-kix_tp0sy78gqk8h-5{list-style-type:none}ul.lst-kix_tp0sy78gqk8h-6{list-style-type:none}.lst-kix_aym92u45ik1k-8>li:before{content:"\0025a0   "}ul.lst-kix_tp0sy78gqk8h-3{list-style-type:none}ul.lst-kix_tp0sy78gqk8h-4{list-style-type:none}ul.lst-kix_tp0sy78gqk8h-1{list-style-type:none}ul.lst-kix_tp0sy78gqk8h-2{list-style-type:none}.lst-kix_zcnwg2w0gc0a-4>li:before{content:"\0025cb   "}ul.lst-kix_tp0sy78gqk8h-0{list-style-type:none}.lst-kix_rfrm939i8yuf-4>li:before{content:"\0025cb   "}.lst-kix_aym92u45ik1k-6>li:before{content:"\0025cf   "}.lst-kix_rfrm939i8yuf-2>li:before{content:"\0025a0   "}.lst-kix_aym92u45ik1k-0>li:before{content:"\0025cf   "}.lst-kix_aym92u45ik1k-4>li:before{content:"\0025cb   "}.lst-kix_lm8x8nf1pj3r-2>li:before{content:"\0025a0   "}.lst-kix_rfrm939i8yuf-0>li:before{content:"\0025cf   "}.lst-kix_aym92u45ik1k-2>li:before{content:"\0025a0   "}.lst-kix_lm8x8nf1pj3r-0>li:before{content:"\0025cf   "}.lst-kix_prld07vdvfck-8>li:before{content:"\0025a0   "}.lst-kix_prld07vdvfck-6>li:before{content:"\0025cf   "}.lst-kix_lm8x8nf1pj3r-4>li:before{content:"\0025cb   "}.lst-kix_prld07vdvfck-4>li:before{content:"\0025cb   "}ul.lst-kix_s4a31qtu9lv3-0{list-style-type:none}ul.lst-kix_s4a31qtu9lv3-1{list-style-type:none}ul.lst-kix_s4a31qtu9lv3-2{list-style-type:none}ul.lst-kix_s4a31qtu9lv3-3{list-style-type:none}.lst-kix_lm8x8nf1pj3r-6>li:before{content:"\0025cf   "}ul.lst-kix_s4a31qtu9lv3-4{list-style-type:none}.lst-kix_rfrm939i8yuf-6>li:before{content:"\0025cf   "}ul.lst-kix_s4a31qtu9lv3-5{list-style-type:none}ul.lst-kix_s4a31qtu9lv3-6{list-style-type:none}ul.lst-kix_s4a31qtu9lv3-7{list-style-type:none}ul.lst-kix_s4a31qtu9lv3-8{list-style-type:none}.lst-kix_rfrm939i8yuf-8>li:before{content:"\0025a0   "}.lst-kix_prld07vdvfck-2>li:before{content:"\0025a0   "}.lst-kix_lm8x8nf1pj3r-8>li:before{content:"\0025a0   "}ul.lst-kix_rfrm939i8yuf-7{list-style-type:none}ul.lst-kix_rfrm939i8yuf-6{list-style-type:none}ul.lst-kix_rfrm939i8yuf-8{list-style-type:none}.lst-kix_drqcbiukht3e-1>li:before{content:"\0025cb   "}ul.lst-kix_rfrm939i8yuf-1{list-style-type:none}ul.lst-kix_rfrm939i8yuf-0{list-style-type:none}ul.lst-kix_rfrm939i8yuf-3{list-style-type:none}ul.lst-kix_rfrm939i8yuf-2{list-style-type:none}ul.lst-kix_rfrm939i8yuf-5{list-style-type:none}ul.lst-kix_rfrm939i8yuf-4{list-style-type:none}.lst-kix_s4a31qtu9lv3-7>li:before{content:"\0025cb   "}.lst-kix_s4a31qtu9lv3-6>li:before{content:"\0025cf   "}.lst-kix_s4a31qtu9lv3-8>li:before{content:"\0025a0   "}ul.lst-kix_drqcbiukht3e-7{list-style-type:none}ul.lst-kix_drqcbiukht3e-6{list-style-type:none}ul.lst-kix_drqcbiukht3e-8{list-style-type:none}ul.lst-kix_4t4rzoylkxr4-6{list-style-type:none}.lst-kix_s4a31qtu9lv3-3>li:before{content:"\0025cf   "}ul.lst-kix_4t4rzoylkxr4-7{list-style-type:none}ul.lst-kix_4t4rzoylkxr4-4{list-style-type:none}.lst-kix_s4a31qtu9lv3-2>li:before{content:"\0025a0   "}.lst-kix_s4a31qtu9lv3-4>li:before{content:"\0025cb   "}ul.lst-kix_4t4rzoylkxr4-5{list-style-type:none}.lst-kix_s4a31qtu9lv3-1>li:before{content:"\0025cb   "}.lst-kix_s4a31qtu9lv3-5>li:before{content:"\0025a0   "}ul.lst-kix_4t4rzoylkxr4-8{list-style-type:none}ul.lst-kix_4t4rzoylkxr4-2{list-style-type:none}ul.lst-kix_4t4rzoylkxr4-3{list-style-type:none}ul.lst-kix_4t4rzoylkxr4-0{list-style-type:none}ul.lst-kix_4t4rzoylkxr4-1{list-style-type:none}.lst-kix_s4a31qtu9lv3-0>li:before{content:"\0025cf   "}ul.lst-kix_lm8x8nf1pj3r-0{list-style-type:none}ul.lst-kix_lm8x8nf1pj3r-1{list-style-type:none}ul.lst-kix_lm8x8nf1pj3r-4{list-style-type:none}ul.lst-kix_lm8x8nf1pj3r-5{list-style-type:none}ul.lst-kix_lm8x8nf1pj3r-2{list-style-type:none}ul.lst-kix_lm8x8nf1pj3r-3{list-style-type:none}.lst-kix_av8977phuwuc-7>li:before{content:"\0025cb   "}.lst-kix_nr7rjikmf5cy-8>li:before{content:"\0025a0   "}.lst-kix_av8977phuwuc-6>li:before{content:"\0025cf   "}.lst-kix_nr7rjikmf5cy-5>li:before{content:"\0025a0   "}.lst-kix_nr7rjikmf5cy-7>li:before{content:"\0025cb   "}.lst-kix_av8977phuwuc-1>li:before{content:"\0025cb   "}.lst-kix_av8977phuwuc-0>li:before{content:"\0025cf   "}.lst-kix_av8977phuwuc-8>li:before{content:"\0025a0   "}.lst-kix_nr7rjikmf5cy-6>li:before{content:"\0025cf   "}.lst-kix_nr7rjikmf5cy-1>li:before{content:"\0025cb   "}.lst-kix_nr7rjikmf5cy-3>li:before{content:"\0025cf   "}.lst-kix_av8977phuwuc-2>li:before{content:"\0025a0   "}.lst-kix_nr7rjikmf5cy-0>li:before{content:"\0025cf   "}.lst-kix_nr7rjikmf5cy-4>li:before{content:"\0025cb   "}.lst-kix_av8977phuwuc-3>li:before{content:"\0025cf   "}.lst-kix_av8977phuwuc-5>li:before{content:"\0025a0   "}.lst-kix_av8977phuwuc-4>li:before{content:"\0025cb   "}.lst-kix_nr7rjikmf5cy-2>li:before{content:"\0025a0   "}.lst-kix_zcnwg2w0gc0a-1>li:before{content:"\0025cb   "}.lst-kix_aym92u45ik1k-5>li:before{content:"\0025a0   "}.lst-kix_zcnwg2w0gc0a-3>li:before{content:"\0025cf   "}.lst-kix_aym92u45ik1k-7>li:before{content:"\0025cb   "}.lst-kix_rfrm939i8yuf-3>li:before{content:"\0025cf   "}.lst-kix_aym92u45ik1k-1>li:before{content:"\0025cb   "}.lst-kix_lm8x8nf1pj3r-3>li:before{content:"\0025cf   "}.lst-kix_rfrm939i8yuf-1>li:before{content:"\0025cb   "}.lst-kix_lm8x8nf1pj3r-1>li:before{content:"\0025cb   "}.lst-kix_aym92u45ik1k-3>li:before{content:"\0025cf   "}.lst-kix_prld07vdvfck-7>li:before{content:"\0025cb   "}.lst-kix_prld07vdvfck-5>li:before{content:"\0025a0   "}.lst-kix_lm8x8nf1pj3r-5>li:before{content:"\0025a0   "}.lst-kix_rfrm939i8yuf-5>li:before{content:"\0025a0   "}ul.lst-kix_lm8x8nf1pj3r-8{list-style-type:none}.lst-kix_prld07vdvfck-1>li:before{content:"\0025cb   "}ul.lst-kix_lm8x8nf1pj3r-6{list-style-type:none}.lst-kix_lm8x8nf1pj3r-7>li:before{content:"\0025cb   "}ul.lst-kix_lm8x8nf1pj3r-7{list-style-type:none}.lst-kix_prld07vdvfck-3>li:before{content:"\0025cf   "}.lst-kix_rfrm939i8yuf-7>li:before{content:"\0025cb   "}ul.lst-kix_nr7rjikmf5cy-8{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-7{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-6{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-5{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-4{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-3{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-2{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-1{list-style-type:none}ul.lst-kix_nr7rjikmf5cy-0{list-style-type:none}ul.lst-kix_drqcbiukht3e-3{list-style-type:none}ul.lst-kix_drqcbiukht3e-2{list-style-type:none}ul.lst-kix_drqcbiukht3e-5{list-style-type:none}ul.lst-kix_drqcbiukht3e-4{list-style-type:none}ul.lst-kix_drqcbiukht3e-1{list-style-type:none}ul.lst-kix_drqcbiukht3e-0{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_aym92u45ik1k-2{list-style-type:none}.lst-kix_drqcbiukht3e-0>li:before{content:"\0025cf   "}ul.lst-kix_aym92u45ik1k-1{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-0{list-style-type:none}ul.lst-kix_aym92u45ik1k-4{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-1{list-style-type:none}ul.lst-kix_aym92u45ik1k-3{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-2{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-3{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-4{list-style-type:none}ul.lst-kix_aym92u45ik1k-0{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-5{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-6{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-7{list-style-type:none}ul.lst-kix_zcnwg2w0gc0a-8{list-style-type:none}ul.lst-kix_aym92u45ik1k-6{list-style-type:none}ul.lst-kix_aym92u45ik1k-5{list-style-type:none}ul.lst-kix_aym92u45ik1k-8{list-style-type:none}ul.lst-kix_aym92u45ik1k-7{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c13{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:256.5pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:225pt;border-top-color:#000000;border-bottom-style:solid}.c0{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c12{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Roboto";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Roboto";font-style:italic}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Roboto";font-style:normal}.c27{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:right;height:11pt}.c6{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Roboto";font-style:normal}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c8{font-size:12pt;font-family:"Roboto";font-style:italic;font-weight:400}.c31{border-spacing:0;border-collapse:collapse;margin-right:auto}.c30{font-weight:400;font-size:11pt;font-family:"Arial"}.c29{font-weight:400;font-size:15pt;font-family:"Roboto"}.c7{font-size:12pt;font-family:"Roboto";font-weight:700}.c21{font-weight:400;font-size:8pt;font-family:"Courier New"}.c11{font-size:12pt;font-family:"Roboto";font-weight:400}.c35{-webkit-text-decoration-skip:none;text-decoration:underline;text-decoration-skip-ink:none}.c15{color:#000000;text-decoration:none;vertical-align:baseline}.c19{font-weight:400;font-size:10pt;font-family:"Roboto"}.c23{font-size:15pt;font-family:"Roboto";font-weight:700}.c24{font-size:10pt;font-family:"Courier New";font-weight:400}.c34{font-weight:700;font-size:20pt;font-family:"Roboto"}.c10{font-size:12pt;font-family:"Courier New";font-weight:400}.c33{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c16{margin-left:36pt;text-indent:36pt}.c25{padding:0;margin:0}.c26{text-indent:36pt}.c18{font-style:normal}.c32{background-color:#ffff00}.c17{font-style:italic}.c9{height:0pt}.c28{margin-left:144pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c33 doc-content"><p class="c3"><span class="c6">CS 106L Winter 2020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c1"><span class="c6"></span></p><p class="c14"><span class="c15 c18 c34">Assignment 1: GraphViz</span></p><p class="c14"><span class="c5">Assignment by Keith Schwartz, revised by Avery Wang</span></p><p class="c14"><span class="c5">Due date: Jan. 30, 2020, at 11:59 pm on Paperless.</span></p><p class="c14"><span class="c5">See update log for minor updates. We&#39;ll send an email if there are major updates.</span></p><p class="c14"><span class="c5">Note: We&#39;ve significantly shortened the handout. Let us know if you find any mistakes!</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c12">Introduction</span></p><p class="c3"><span class="c11">One of the most useful abstractions in computer science is a graph, a means of expressing relationships between objects. Formally, a graph is a collection of </span><span class="c8">nodes</span><span class="c11">&nbsp;(sometimes called </span><span class="c8">vertices</span><span class="c11">), and </span><span class="c8">edges</span><span class="c11">&nbsp;(sometimes called </span><span class="c8">arcs</span><span class="c2">), where each node represents some object, and each edge connects two nodes that are somehow related. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">For example, suppose we had a group of students, who were named Alice, Bob, Christine, David, and Eveyln, and their friendships were as follow:</span></p><ul class="c25 lst-kix_rfrm939i8yuf-0 start"><li class="c0 li-bullet-0"><span class="c2">Alice, Christine, and David, are all friends.</span></li><li class="c0 li-bullet-0"><span class="c2">Bob and Christine are friends.</span></li><li class="c0 li-bullet-0"><span class="c2">Evelyn and Alice are friends.</span></li></ul><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">We can represent this friend group as a graph, where the nodes are the students, and the edges connected pairs of students who were friends. In this example, our graph would be:</span></p><p class="c3"><span class="c15 c10 c18">nodes: {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Christine&quot;, &quot;David&quot;, &quot;Evelyn&quot;}</span></p><p class="c3"><span class="c15 c10 c18">edges: {{&quot;Alice&quot;, &quot;Christine&quot;}, {&quot;Alice&quot;, &quot;David&quot;}, {&quot;Bob&quot;, &quot;Christine&quot;}, {&quot;David&quot;, &quot;Christine&quot;}, {&quot;Evelyn&quot;, &quot;Alice&quot;}}</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c11">It&#39;s difficult to understand the friendship structure of this graph by simply listing the nodes and edges. Instead, we visualize the graph by drawing the nodes as points, and edges as lines connecting the nodes. For example, the friendship graph can be visualized in many ways, and three are drawn below. </span><span class="c7 c15 c18 c32">TODO: Fix the graph, doesn&#39;t match the example above. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 142.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 142.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">Figure 1 (above): Three possible visualizations for the graph above.</span></p><p class="c3"><span class="c11">All of these graphs correctly represent the friends between a group of friends. </span><span class="c7">However, they vary in the </span><span class="c7 c35">locations of the nodes</span><span class="c7">. </span><span class="c2">Which graph is easiest to interpret? The blue graph clearly shows the local structures within friend groups, especially the central group of friends Alice, Christine, and David. The other two graphs, while still valid visualizations, make the friend group harder to interpret. For example, in the green graph, it looks like Evelyn is closely related to Christine or Bob, even though Evelyn is connected to neither. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">In summary, we&#39;ll use the following two heuristics to change the locations of the nodes, in order to create a well-visualized graph.</span></p><ul class="c25 lst-kix_4t4rzoylkxr4-0 start"><li class="c0 li-bullet-0"><span class="c7">Minimize the distances between nodes that are connected.</span><span class="c2">&nbsp;The idea is that if connected nodes are near each other, then the reader can focus on one part of the graph and see the local structure within that region.</span></li><li class="c0 li-bullet-0"><span class="c7">Maximize the distances between nodes that are not connected. </span><span class="c2">The idea is that otherwise, the reader could believe the nodes are somehow related, even if they are not connected.</span></li></ul><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Solving for an optimal solution with the above constraints is a tough problem. However, we can instead start with a random visualization, and then continually try to improve the visualization. Remarkably, the laws of physics can be applied on these nodes! Each node exerts a force on other nodes, which will push and pull suboptimal nodes until they are in the correct position. More specifically...</span></p><ul class="c25 lst-kix_drqcbiukht3e-0 start"><li class="c0 li-bullet-0"><span class="c2">Every edge exerts an attractive force between two connected nodes, pulling the connected nodes together.</span></li><li class="c0 li-bullet-0"><span class="c2">Every node exerts a repulsive force on every other node, pushing the pair of nodes away, whether or not they are connected.</span></li></ul><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Here is the pseudocode:</span></p><p class="c3"><span class="c4">Assign each node to an initial location around a circle.</span></p><p class="c3"><span class="c4">Add all the edges within the graph.</span></p><p class="c3"><span class="c4">While the layout is not yet finished:</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Have each edge exert an attractive force on its endpoints.</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Have each node exert a repulsive force on all other nodes.</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Move the nodes according to the net force </span></p><p class="c3 c16"><span class="c4">that node experiences in this iteration.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c12">Implementation Details</span></p><p class="c3"><span class="c2">Here are the steps and details to each part of the assignment.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c17">1. Prompt the user for the name of a file that contains the graph data, and open the file. If unsuccessful, reprompt.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">How can you check whether a file was successfully opened? When you declare an ifstream (input file stream, which will be used later to read the file), you pass the filename to the constructor. You can check if a file failed to open correctly by checking the fail bit. If the fail bit is not on, you can assume the file was successfully opened!</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c17">2. Prompt the user for the number of microseconds to run the algorithm, which should be a positive integer. If the input is invalid, reprompt.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">This is a slight twist on the function we wrote in class, getInteger(). Try to not look at the example code there. Try to implement this function yourself!</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c17">3. Place all the nodes in a circle</span><span class="c7 c15 c18">. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c11">The first line of the file tells you exactly how many nodes are in the circle. Once you figure out the number of nodes </span><span class="c8">n</span><span class="c2">, you can use the unit circle to figure out the positions of each node. The angles are expressed in radians.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c4">#include &lt;cmath&gt; // for sin and cos</span></p><p class="c3"><span class="c4">const double kPi = 3.14159265358979323</span></p><p class="c3"><span class="c4">for k = 0, 1, &hellip;, n-1:</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position = (cos(2*kPi*k/n), sin(2*kPi*k/n))</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">As an example, for the file to the right, after placing the nodes in a circle the graph should look like the following (without the numbers - the numbers represent the k in the equation above). At the end of each step, your SimpleGraph&#39;s nodes vector should be filled with n nodes, and indices k = 0, 1, &hellip;, n-1 have nodes at the positions stated above.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 188.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 188.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8 c15">Figure 2: The graph, nodes labeled with indices, immediately after all nodes are placed in a circle. We have only read the first number in the file, 6, the number of nodes.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c11">After you created your graph, the graph will not appear on the canvas until you call the GUI methods, described later in the section &quot;Starter Code Details&quot;.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c17">4. Add all the edges to your graph.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">The rest of the file gives you pairs of indices that are connected by an edge. Read in the indices two at a time, create an edge with the two indices as endpoints, and add this to the edges vector. For example, after reading the example file, your visualized graph should look like this.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Error-checking whether or not the file is well-formatted is not necessary!</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 188.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 188.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c8 c15">Figure 3: The graph, nodes labeled with indices, immediately after all edges have been added to the graph. At this point we have read the entire file.</span></p><p class="c1"><span class="c8 c15"></span></p><p class="c1"><span class="c8 c15"></span></p><p class="c3"><span class="c7 c15 c17">5. Determine when to continue iterating. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">This is the while loop condition. You should keep looping until the elapsed time has exceeded the number of microseconds the user entered. Here is a sample usage of the &lt;chrono&gt; library. Read the documentation for more information!</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c4">#include &lt;chrono&gt; // fancy timers</span></p><p class="c1"><span class="c4"></span></p><p class="c3"><span class="c4">// retrieve current times</span></p><p class="c3"><span class="c4">auto start = std::chrono::high_resolution_clock::now();</span></p><p class="c3"><span class="c4">auto end = std::chrono::high_resolution_clock::now();</span></p><p class="c1"><span class="c4"></span></p><p class="c3"><span class="c4">// calculate elapsed time, and convert to milliseconds</span></p><p class="c3"><span class="c4">auto elapsed = </span></p><p class="c3 c26"><span class="c4">std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start); </span></p><p class="c3"><span class="c24">int milliseconds = elapsed.count();</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c17">6. Compute the attractive force between the endpoints of each edge. </span></p><p class="c1"><span class="c8 c15"></span></p><p class="c3"><span class="c2">Keith&#39;s old handout had a ton of explanation of the physics behind the algorithm, which was a bit intimidating. If math terrifies you, here are the equations in code:</span></p><p class="c3"><span class="c4">const double kattract = 0.001;</span></p><p class="c3"><span class="c4">For each edge:</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Let first endpoint be (x0, y0)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Let second endpoint be (x1, y1)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute Fattract = </span></p><p class="c3 c16"><span class="c4">kattract * ((y1-y0)*(y1-y0) + (x1-x0)*(x1-x0))</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute theta = atan2(y1 - y0, x1 - x0)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_x0 += Fattract * cos(theta)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_y0 += Fattract * sin(theta)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_x1 -= Fattract * cos(theta)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_y1 -= Fattract * sin(theta)</span></p><p class="c3"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c3"><span class="c7 c15 c17">7. Compute the repulsive force between every pair of nodes. </span></p><p class="c3"><span class="c4">const double krepel = 0.001;</span></p><p class="c3"><span class="c4">For every pair of nodes (x0, y0) and (x1, y1):</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute Frepel = </span></p><p class="c3 c16"><span class="c4">krepel / sqrt((y1-y0)*(y1-y0) + (x1-x0)*(x1-x0))</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute theta = atan2(y1 - y0, x1 - x0)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_x0 -= Frepel * cos(theta)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_y0 -= Frepel * sin(theta)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_x1 += Frepel * cos(theta)</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta_y1 += Frepel * sin(theta)</span></p><p class="c3"><span class="c4">*If you love physics, try to figure out these equations!</span></p><p class="c3"><span class="c7 c15 c17">8. Sum up the forces (delta&#39;s) for each node across all calculations in part 7 and 8, and move the positions of that node by the amount of the force.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">In each iteration, you need to keep track all of the delta_x&#39;s and delta_y&#39;s for every node in your graph. At the end of the iteration, you should then adjust the positions (x, y) of each node by delta_x and delta_y respectively.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c17">9. Ask the user if they want to try another file, and loop accordingly.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Don&#39;t use recursion here!</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c12">Starter Code Details</span></p><p class="c3"><span class="c11">In the starter code, everything is set up except main.cpp. You will write the entire program, starting from the main function. </span><span class="c7">Do not modify any other files, such as SimpleGraph.h. </span><span class="c2">In SimpleGraph.h, the following structures are defined for you.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c18">Structures</span></p><p class="c3"><span class="c2">In this assignment, we will represent the graph as a struct, defined as follows:</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c15 c10 c18">struct SimpleGraph {</span></p><p class="c3"><span class="c15 c10 c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Node&gt; nodes;</span></p><p class="c3"><span class="c15 c10 c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::vector&lt;Edge&gt; edges;</span></p><p class="c3"><span class="c15 c10 c18">};</span></p><p class="c1"><span class="c15 c10 c18"></span></p><p class="c3"><span class="c2">Each node is represented by a Node struct, which simply stores the (x, y) coordinate of each Node. This coordinate is useful when we try to visualize the graph.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c15 c10 c18">struct Node {</span></p><p class="c3"><span class="c15 c10 c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double x, y;</span></p><p class="c3"><span class="c10">};</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">Finally, an edge identifies the two nodes that it connects. The easiest way to identify a Node is through the index the Node is stored in a vector. Recall that size_t is an unsigned integer representing sizes or indices that must be non-negative. As a result, we define an edge as follows:</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c15 c10 c18">struct Edge {</span></p><p class="c3"><span class="c15 c10 c18">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t start, end;</span></p><p class="c3"><span class="c15 c10 c18">};</span></p><p class="c1"><span class="c15 c10 c18"></span></p><p class="c3"><span class="c2">All of our graphs will be undirected, which means that edges are bidirectional. If A is connected to B, then B is connected to A. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">For example, if we were to store the following graph in a SimpleGraph struct, we would have the following in our vector:</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 188.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 188.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">Figure 5: The graph we had before, and how this would be represented in our SimpleGraph struct.</span></p><p class="c3"><span class="c4">SimpleGraph {</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// xi, yi stands for the x or y coordinates of each point</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodes: { {x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}, {x4, y4}, {x5, y5}}</span></p><p class="c3"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edges: { {0, 1}, {5, 2}, {3, 0}, {4, 5} }</span></p><p class="c3"><span class="c4">}</span></p><p class="c1"><span class="c4"></span></p><p class="c3"><span class="c7">GUI Functions</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c2">You do not need to write any code for the graphics. Simply create your graph, and call the following two functions in your code.</span></p><p class="c1"><span class="c2"></span></p><a id="t.339235b725b4288124f95f1398503ad47a689f35"></a><a id="t.0"></a><table class="c31"><tr class="c9"><td class="c20" colspan="1" rowspan="1"><p class="c22"><span class="c15 c19 c18">Function Name</span></p></td><td class="c13" colspan="1" rowspan="1"><p class="c22"><span class="c15 c18 c19">Description</span></p></td></tr><tr class="c9"><td class="c20" colspan="1" rowspan="1"><p class="c22"><span class="c15 c18 c21">void DrawGraph(SimpleGraph&amp; graph)</span></p></td><td class="c13" colspan="1" rowspan="1"><p class="c22"><span class="c15 c19 c18">Takes in a SimpleGraph, and draws the graph on the canvas. Call once in every iteration of the algorithm, and whenever you want the graph visualizer to update.</span></p></td></tr><tr class="c9"><td class="c20" colspan="1" rowspan="1"><p class="c22"><span class="c21 c15 c18">void InitGraphVisualizer(SimpleGraph&amp; graph)</span></p></td><td class="c13" colspan="1" rowspan="1"><p class="c22"><span class="c15 c19 c18">Sets up the internal state of the graph visualizer. Call once at the beginning of your program.</span></p></td></tr></table><p class="c3"><span class="c12">Advice and Common Mistakes</span></p><ul class="c25 lst-kix_tp0sy78gqk8h-0 start"><li class="c0 li-bullet-0"><span class="c2">Don&#39;t hesitate to ask questions! We want to give you practice building a cool program in Standard C++, not to punish you for not knowing a particular library or language feature. Ask on Piazza!</span></li><li class="c0 li-bullet-0"><span class="c2">Create one single SimpleGraph, and use it throughout your program. Do not copy the SimpleGraph, as that may cause bugs in the graphical canvas.</span></li><li class="c0 li-bullet-0"><span class="c2">Be careful about reading files. As mentioned in lecture, eof and good bits are difficult to use and can cause off-by-one errors. If you are seeing an extra garbage edge, there is likely a bug in your loop. </span></li><li class="c0 li-bullet-0"><span class="c2">Be careful when receiving input from the user. As mentioned in lecture, reading directly using &gt;&gt; from cin is a nightmare. See lecture examples for techniques to get around that. </span></li></ul><ul class="c25 lst-kix_prld07vdvfck-0 start"><li class="c0 li-bullet-0"><span class="c2">Label the points exactly as (x0, y0) and (x1, y1). Being clever with names will only confuse you. Don&#39;t use (x2, y2) or (x&#39;, y&#39;).</span></li><li class="c0 li-bullet-0"><span class="c2">There is no square root when calculating Fattract, but there is a square root when calculating Frepel.</span></li><li class="c0 li-bullet-0"><span class="c2">When calculating atan2, make sure you are using y1 - y0 not y0 - y1.</span></li><li class="c0 li-bullet-0"><span class="c2">Do not confuse your +=&#39;s vs. -=&#39;s. Make sure they match up with the x0&#39;s vs. x1&#39;s exactly. Yes, they are flipped if you compare attractive with repulsive.</span></li><li class="c0 li-bullet-0"><span class="c2">Use C++ constructs. Do not use: C-strings/functions, functions dealing with memory, #define, printf, etc. Only use material covered in the first two weeks of CS 106B/L (except Stanford libraries, of course!).</span></li><li class="c0 li-bullet-0"><span class="c2">Do not modify any files other than main.cpp. In particular, do not add your own structs inside SimpleGraph.h, and do not change the definitions for SimpleGraph, Node, Edge, or anything else provided in the starter code.</span></li></ul><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c12">Grading</span></p><p class="c3"><span class="c2">Here are the minimum functionality requirements to receive credit on the assignment.</span></p><ul class="c25 lst-kix_nr7rjikmf5cy-0 start"><li class="c0 li-bullet-0"><span class="c2">Program must compile (this means you only modified main.cpp).</span></li><li class="c0 li-bullet-0"><span class="c2">Program must not use any Stanford Library functions. </span></li><li class="c0 li-bullet-0"><span class="c2">User must be able to enter a filename and a time. After the time has elapsed, the user must be able to type in &quot;yes&quot; or &quot;no&quot;, and the program should reprompt accordingly. </span></li><li class="c0 li-bullet-0"><span class="c2">A reasonable attempt at error-checking and re-prompting for all user input.</span></li><li class="c0 li-bullet-0"><span class="c2">On the input files &#39;cube&#39; given a large enough time, the program should terminate with the visualizer displaying a cube (orientation isn&#39;t important).</span></li></ul><p class="c3 c28"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 246.50px; height: 245.23px;"><img alt="" src="images/image3.png" style="width: 246.50px; height: 245.23px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3 c28"><span class="c8 c15">Figure 4: This is what a cube looks like.</span></p><p class="c1"><span class="c2"></span></p><ul class="c25 lst-kix_nr7rjikmf5cy-0"><li class="c0 li-bullet-0"><span class="c2">On the input file&#39;10grid&#39;, correct inputs when run on various time durations. If a very small time is used, the visualization should look close to a circle. If a medium time is used the visualizer should terminate even if the graph has not converged. If a large time is used, the graph should look like a cube, as shown below. We are purposely vague about what &quot;small&quot;, &quot;medium&quot;, and &quot;large&quot; are, and we&#39;re flexible as long as your program reasonably works correctly.</span></li></ul><p class="c1"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 342.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 342.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c8">Figure 5: Sample runs with the &#39;10grid&#39; file. The program should converge at the graph in the bottom right.</span></p><p class="c3"><span class="c23">Style Guidelines</span></p><p class="c3"><span class="c2">We will offer feedback on style, though we won&#39;t include style as part of your grade. Here are some things to keep in mind.</span></p><ul class="c25 lst-kix_zcnwg2w0gc0a-0 start"><li class="c0 li-bullet-0"><span class="c2">We said this once above, and we&#39;ll say it again. Stick with Standard C++! Particularly if you&#39;ve coded in C, you may be tempted to use C constructs such as C-strings, arrays, macros (#defines), and memory manipulations. Resist that temptation, and code with the powerful language that is C++. You will find the code much easier to write in C++. </span></li><li class="c0 li-bullet-0"><span class="c2">Think about when a pair, tuple, struct, and vector are best used. For example, if you wanted to store a coordinates (x, y), a vector of size two should not be used, since vectors are meant to be used as dynamically sized containers.</span></li><li class="c0 li-bullet-0"><span class="c2">Everything from CS 106B still matter! Decomposition, avoiding redundancy, naming your variable and functions well - these are all important!</span></li><li class="c0 li-bullet-0"><span class="c2">Avoid using anything past lecture 4 (vectors). This assignment is quite simple, and we don&#39;t want you diving into iterators and algorithms until you&#39;ve mastered the material from the first four lectures. </span></li></ul><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c23">Extensions</span></p><p class="c3"><span class="c2">Here are a few possible extensions you may want to experiment with. </span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c11">1. </span><span class="c7">Add node velocities.</span><span class="c2">&nbsp;In our current algorithm, the amount each node moves is independent in each iteration. If we really implemented this as a force-directed algorithm, the forces should cause the nodes to speed up or slow down over multiple iterations.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c11">2. </span><span class="c7">Add penalties for crossing edges</span><span class="c2">. One aspect of graph drawings we did not</span></p><p class="c3"><span class="c2">take into account when computing forces is the number of edges that are</span></p><p class="c3"><span class="c2">crossing in a particular drawing. Modify the algorithm to detect these crossings and adjust the layout accordingly. One common approach for doing this is to pretend that there is an invisible node at the center of each edge that exerts a repulsive force against the center of each other edge, thus pushing edges apart from one another.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c11">3. </span><span class="c7">Add penalties for low resolution.</span><span class="c2">&nbsp;The resolution of a graph drawing is the smallest angle between any two edges incident to a single node. Graphs that have low resolution can be hard to understand, since the edges emanating from a source node will all be bunched together. One way to do this might be to add a repulsive force between the endpoints of arcs that have a small angle between them.</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c12">Submission Instructions</span></p><p class="c3"><span class="c2">Visit Paperless, click on CS 106L, and submit main.cpp. You should not have modified any other files. If you submit extensions, please submit them in the same submission named as main-extra-1.cpp, main-extra-2.cpp, etc. Let us know if you have trouble submitting.</span></p><p class="c1"><span class="c2"></span></p><p class="c3"><span class="c7 c15 c18">Good luck with the assignment! Don&#39;t hesitate to ask on Piazza if you have questions.</span></p><p class="c1"><span class="c7 c15 c18"></span></p><p class="c1"><span class="c7 c15 c18"></span></p><p class="c3"><span class="c12">Update Log</span></p><p class="c3"><span class="c2">Every time there is an update to this document, I will log it below, so you can easily see if any changes were made.</span></p><p class="c3"><span class="c2">Jan. 23, 2:13 AM - added update log, added note that krepel = kattract = 0.001</span></p><p class="c3"><span class="c2">Feb. 2, 12:54 PM - changed microseconds to milliseconds in the chrono class. We will accept both, although you&#39;ll find yourself typing less 0&#39;s if you use milliseconds.</span></p><div><p class="c27"><span class="c15 c18 c30"></span></p></div></body></html>